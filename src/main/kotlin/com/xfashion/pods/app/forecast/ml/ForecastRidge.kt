package com.xfashion.pods.app.forecast.ml

import org.apache.commons.math3.linear.*

/**
 * This code is generated by chatGPT :)
 *
 * We train separate models:
 * fe_pods ← β0 + β1*gmv + β2*users + β3*marketing_cost + weekday dummies
 * be_pods ← β0 + β1*gmv + β2*users + β3*marketing_cost + weekday dummies
 *
 * ForecastRidge: solve (XᵀX + λI)β = Xᵀy. Using Commons Math matrices.
 */

data class ForecastFitResult(
    val coefficients: DoubleArray,
    val featureNames: List<String>
)

object ForecastRidge {
    fun fit(x: Array<DoubleArray>, y: DoubleArray, lambda: Double): ForecastFitResult {

        val cols = x[0].size
        val xMat = Array2DRowRealMatrix(x)
        val yVec = ArrayRealVector(y)
        val xtx = xMat.transpose().multiply(xMat)

        // add ridge penalty (do not regularize intercept at index 0)
        val ridge = Array2DRowRealMatrix(cols, cols)
        for (i in 1 until cols) {
            ridge.setEntry(i, i, lambda)
        }
        val a = xtx.add(ridge)
        val xty = xMat.transpose().operate(yVec)
        val solver = LUDecomposition(a).solver
        val beta = solver.solve(xty)

        return ForecastFitResult(beta.toArray(), emptyList())
    }

    fun predict(beta: DoubleArray, x: DoubleArray): Double {

        var s = 0.0
        for (i in x.indices) s += beta[i] * x[i]
        return s
    }
}